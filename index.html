<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Backrooms Maze</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background: black;
      }
      canvas {
        display: block;
      }
      #startButton {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 24px;
        padding: 12px 24px;
        cursor: pointer;
      }
    </style>
  </head>
  <body>
    <button id="startButton">Click to Start</button>
    <script type="module">
      import * as THREE from 'https://cdn.skypack.dev/three';
      import { PointerLockControls } from 'https://cdn.skypack.dev/three/examples/jsm/controls/PointerLockControls.js';

      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      const controls = new PointerLockControls(camera, document.body);
      scene.add(controls.getObject());

      document.getElementById('startButton').addEventListener('click', () => {
        controls.lock();
      });

      // Lighting
      const light = new THREE.HemisphereLight(0xffffff, 0x888888, 1);
      scene.add(light);

      // Load and tint texture
      function makeRGBMaterial(texture, r, g, b, repeatX, repeatY) {
        texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
        texture.repeat.set(repeatX, repeatY);
        const mat = new THREE.MeshStandardMaterial({
          map: texture,
          color: new THREE.Color(r, g, b),
        });
        return mat;
      }

      const loader = new THREE.TextureLoader();
      const wallTex = loader.load('textures/wall.jpeg');
      const floorTex = loader.load('textures/floor.jpg');
      const ceilTex = loader.load('textures/ceiling.jpg');

      const wallMat = makeRGBMaterial(wallTex, 0.9, 0.8, 0.8, 2, 1);
      const floorMat = makeRGBMaterial(floorTex, 1.1, 1.1, 1.1, 8, 8);
      const ceilMat = makeRGBMaterial(ceilTex, 0.75, 0.7, 0.4, 2, 2);

      // Floor
      const floor = new THREE.Mesh(new THREE.PlaneGeometry(100, 100), floorMat);
      floor.rotation.x = -Math.PI / 2;
      scene.add(floor);

      // Ceiling
      const ceiling = new THREE.Mesh(new THREE.PlaneGeometry(100, 100), ceilMat);
      ceiling.position.y = 4;
      ceiling.rotation.x = Math.PI / 2;
      scene.add(ceiling);

      // Maze Layout (grid-based)
      const maze = [
        'XXXXXXXXXX',
        'X        X',
        'X XXXXX  X',
        'X X   X  X',
        'X X X XXXX',
        'X   X    X',
        'XXXXXXXXXX'
      ];

      const wallSize = 4;
      for (let z = 0; z < maze.length; z++) {
        for (let x = 0; x < maze[z].length; x++) {
          if (maze[z][x] === 'X') {
            const wall = new THREE.Mesh(new THREE.BoxGeometry(wallSize, 4, wallSize), wallMat);
            wall.position.set((x - maze[0].length / 2) * wallSize, 2, (z - maze.length / 2) * wallSize);
            wall.userData.solid = true;
            scene.add(wall);
          }
        }
      }

      // Player movement
      let velocity = new THREE.Vector3();
      let direction = new THREE.Vector3();
      const speed = 1;
      const jumpSpeed = 10;
      let canJump = false;

      const keys = {};
      document.addEventListener('keydown', e => keys[e.code] = true);
      document.addEventListener('keyup', e => keys[e.code] = false);

      let raycaster = new THREE.Raycaster();

      function checkCollisions() {
        raycaster.set(controls.getObject().position, new THREE.Vector3(0, -1, 0));
        const intersects = raycaster.intersectObjects(scene.children);
        canJump = intersects.length > 0 && intersects[0].distance < 1.75;
      }

      function animate() {
        requestAnimationFrame(animate);

        direction.set(0, 0, 0);
        if (keys['KeyW']) direction.z -= 1;
        if (keys['KeyS']) direction.z += 1;
        if (keys['KeyA']) direction.x -= 1;
        if (keys['KeyD']) direction.x += 1;
        direction.normalize();

        if (controls.isLocked) {
          const front = new THREE.Vector3();
          controls.getDirection(front);
          front.y = 0;
          front.normalize();

          const side = new THREE.Vector3();
          side.crossVectors(front, new THREE.Vector3(0, 1, 0)).normalize();

          velocity.x = (front.x * direction.z + side.x * direction.x) * speed;
          velocity.z = (front.z * direction.z + side.z * direction.x) * speed;

          velocity.y -= 0.5; // gravity
          controls.moveRight(velocity.x);
          controls.moveForward(velocity.z);
          controls.getObject().position.y += velocity.y * 0.1;

          checkCollisions();

          if (canJump) {
            velocity.y = Math.max(0, velocity.y);
            if (keys['Space']) {
              velocity.y = jumpSpeed;
            }
          }

          if (controls.getObject().position.y < 1.75) {
            controls.getObject().position.y = 1.75;
            velocity.y = 0;
            canJump = true;
          }
        }

        renderer.render(scene, camera);
      }

      controls.getObject().position.set(0, 1.75, 0); // start just above floor
      animate();

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
